---           
layout: post
title: The Challenges of Character Encoding... in 2013
date: 2013-02-07 12:46:47 UTC
updated: 2013-02-07 12:46:47 UTC
comments: false
categories: blog
---
 
This article is going to be a bit of a rant.<br /><br />Back when I was a lad, <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a> wasn't as popular as it is now.  The world lived in the Dark Ages, where each text character was usually represented by a single byte, regardless of the language.  A single byte can take up to 256 different values, meaning that on its own, it could be used to represent at most 256 different characters. People wanted to communicate to each other in different languages, but the number of characters in all modern languages was far more than 256. &nbsp;This posed a problem.<br /><br />A commonly accepted solution was to agree that the first 128 character codes were fixed (the <a href="http://en.wikipedia.org/wiki/ASCII">ASCII character set</a>), while the last 128 were unspecified -- their values depended on the context.  A swarm of character encodings emerged, each handling these last 128 characters differently.  For my native Russian, there were at least two such encodings: <a href="http://en.wikipedia.org/wiki/KOI8-R">KOI-8</a> and <a href="http://en.wikipedia.org/wiki/CP1251">CP1251</a>.  When you got text in Russian, you typically had to guess which encoding it was in.  If you got it wrong, all you saw was gibberish (and any English text, since that was handled the same regardless of the encoding).  It was 50/50, so not too bad.  There were also some <a href="http://www.artlebedev.ru/tools/decoder">utilities</a> that helped you guess the encoding.<br /><br />A significant limitation, of course, was that you couldn't freely mix languages in text.  For example, working with Russian and Greek text in the same file was not possible.  Greek used a different encoding, which wasn't compatible with KOI-8 nor CP1251.  You could see Russian or Greek at any one time, but never both.<br /><br />Fast-forward to 2013.  Unicode has become almost universally accepted.  It solved the problems above, introduced <a href="http://web.archive.org/web/20090627072117/http://www.jbrowse.com/text/unij.html">several</a> <a href="http://en.wikipedia.org/wiki/Han_unification">new</a> <a href="http://www.hastingsresearch.com/net/04-unicode-limitations.shtml">ones</a>, but overall, made the world a better place.  The days of staring at gibberish trying to work out which encoding it is in were gone.  Things just worked.  Or so I thought.<br /><br />I recently had the pleasure of playing correspondence chess with my dad using a chess server.  While the game itself was quite entertaining (I lost miserably), I quickly noticed that sending Unicode messages wasn't working -- ASCII characters got through, non-ASCII characters got replaced by a question mark.  This forced us to write in <a href="http://en.wikipedia.org/wiki/Translit">transliterated Russian</a>, which I hate with a passion:  <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/2ZZpIsm.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="518" src="http://i.imgur.com/2ZZpIsm.png" width="427" /></a></div><br />What was obvious that while the Web site was capable of displaying Cyrillic (which I managed to enter using HTML character escapes, thanks to the site admin), it was ruthlessly clobbering the text <i>after</i> it was being submitted.  After looking at it more closely, I realized the input textarea was part of a POST form, and clicking on the "Msg" button submitted the form.  The message was, therefore, part of the POST payload.  I confirmed that it was successfully URL-encoded and still readable by using Chrome's <a href="https://developers.google.com/chrome-developer-tools/">Developer tools</a>.  After that, all trace of the message is lost, but one thing is clear: the non-ASCII characters in the message died a horrible death.<br /><br /><a href="http://imgur.com/X8TV1ZV"><img alt="" src="http://i.imgur.com/X8TV1ZV.png" title="Hosted by imgur.com" /></a><br /><br />While encountering a fairly popular site that could not properly handle Unicode in 2013 was amusing, what was even more amusing was my dialogue with the administrator of the site.  While I do believe they were genuinely trying to help, their firm belief that a server-side encoding problem could be fixed by modifying the client configuration was disconcerting, to say the least.  The more I talked to them, the more I understood that they had no idea how character encoding works.  Unfortunately, they also had little desire to reason about it, which led to a rather tense dialogue:  <br /><blockquote>... the language that you use to handle message input is controlled by your local configuration and this is something over which we have no control.  All of our pages, in common with around 75% of all online content from many diverse sites, are configured to accept input that conforms with UTF-8 standards.  As I have tried to point out, there may well be a local issue relevant to your local configuration, codepage setting, default character coding and so on. These are not issues for which we, as a UK based Chess playing site, normally provide support. In this case, we have offered more support and advice than would have been provided by many of our competitors. </blockquote>I edited the quote above liberally, for brevity.  It can, however, be summarized by a single word in the King's English: <b>bollocks</b>.  What's really happening is this: after the form is submitted, the URL-encoded message is retrieved from the POST payload, and encoded into one of the antique character encodings from the Dark Ages.  Since these encodings only represent characters with codes up to 255, and the Unicode Cyrillic characters sit around the <a href="http://en.wikipedia.org/wiki/Cyrillic_script_in_Unicode">1000 mark</a>, there's simply no way to represent those characters anymore.  Whatever performs the encoding replaces such characters with a placeholder character, which in this case happens to be a question mark.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/93CaAUK.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/93CaAUK.png" /></a></div><br />I mashed up some JavaScript to demonstrate the problem. &nbsp;While I couldn't be bothered doing a full form POST, the code demonstrates the essence of the problem. &nbsp;It's below.<br /><br /><script src="https://gist.github.com/mpenkov/4721121.js"></script> Here's a live version you can interact with. &nbsp;Case closed.<br /><br /><form><textarea cols="70" id="textArea" readonly="true" rows="10"></textarea><br /><input id="inputText" size="50" text="Enter some text here" type="text" value="Enter some Unicode here..." />    <input id="checkbox" type="checkbox" />clobber the submitted text     <input onclick="onSubmit();" type="button" value="Msg" />  </form><br /><script>  // Append the text from inputText to the textArea.  Optionally, clobber the   // text by encoding it to ASCII prior to appending.   function onSubmit() {     var textArea = document.getElementById("textArea");     var inputText = document.getElementById("inputText");     if (textArea.value.length > 0)       textArea.value += "\n";     var checkbox = document.getElementById("checkbox");     var text;     if (checkbox.checked) {       // If you attempt to represent the string using a limited character set,       // then the characters that are not supported by that character set will       // be irrecoverably lost.       //       // Note that this problem is not ASCII-specific: any other encoding that       // does not support the same character set as Unicode, such as KOI-8,       // will also cause the same problem.       text = toUtf16(toAscii(inputText.value));     } else {       // If you keep characters in JavaScript's native UTF-16, then everything        // will work properly, since that encoding supports any character        // imaginable.       text = inputText.value;     }     textArea.value += text;     inputText.value = "";   }   // Converts a UTF-16 string to an array of ASCII codes.   // Non-ASCII characters are replaced with "?", since they cannot by the ASCII   // character set.  Returns the array.   function toAscii(utf16) {     ascii = Array();     for (var i = 0; i < utf16.length; ++i) {       code = utf16.charCodeAt(i);       if (code > 255)         code = "?".charCodeAt(0);       ascii[i] = code;     }     return ascii;   }   // Converts an array of ASCII codes into a normal JavaScript string (signed    // UTF-16).  Returns the string.   function toUtf16(ascii) {     utf16 = Array();     for (var i = 0; i < ascii.length; ++i)       utf16[i] = String.fromCharCode(ascii[i]);     return utf16.join("");   }   </script> Had I been a more patient man, I would have persevered against the onslaught of ignorance and carried on my crusade for working Unicode input to its glorious end.  Instead, I just opened an account on another chess server.
