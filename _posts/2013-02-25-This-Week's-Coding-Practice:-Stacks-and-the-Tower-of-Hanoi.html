---           
layout: post
title: This Week's Coding Practice - Stacks and the Tower of Hanoi
date: 2013-02-25 07:24:19 UTC
updated: 2013-02-25 07:24:19 UTC
comments: false
categories: 
---
 
A stack is a common data type that allows its elements to be accessed in LIFO (last in, first out) order.  Many parts of the physical world around us function like a stack.  A common analogy is a stack of plates on a table: it's simple to put a new plate on top or remove the top-most plate.  It's impossible to insert a new plate into the middle of the stack.  It's also impossible to remove any plates other than the top-most one.  I ran into yet another real-world example of a stack the other day: a narrow rectangular parking lot with only one side facing a driveway. The lot has just enough space to fit around 4-5 cars end-to-end. When people want to park, they just drive straight in. Eventually, they get parked in by someone, who also gets parked in by somebody else, and so on. Lucky last doesn't get parked in by anyone else, but gets nagged by all the people he parked in whenever they want to leave.<br /><br />Another popular example of a stack is the famous&nbsp;<a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi">Tower of Hanoi</a>&nbsp;puzzle. &nbsp;There are three rods, and an arbitrary number of disks of unique sizes. &nbsp;Initially, all the disks are placed on the first rod, ordered by size (smallest disk at the top). &nbsp;The goal of the puzzle is to move all the disks to another rod, one by one, without ever putting a larger disk on top of a smaller one. &nbsp;The task for this week was to write an algorithm that solves this puzzle.<br /><br />It may not be obvious from the description, but each peg can be modeled as a stack, since its physically impossible to access elements in any order other than LIFO (for example, randomly, or FIFO). &nbsp;The entire puzzle is then modeled by 3 separate stacks.<br /><br />How does one go about solving the puzzle? &nbsp;It turns out that it has been <a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi#Solution">thoroughly</a> <a href="http://mathworld.wolfram.com/TowerofHanoi.html">studied</a>, and several well-known recursive and iterative algorithms exist. &nbsp;However, since I have a tendency to do things the hard way, I didn't study those algorithms prior to solving the puzzle, and came up with a less elegant but home-brewed solution on my own.<br /><br />Having spent a significant amount of time on the problems at <a href="http://projecteuler.net/">Project Euler</a>, I've acquired a instinctive reaction: whenever facing a problem for the first time, try brute force. &nbsp;It's almost never the best (or even borderline satisfactory) solution, but is a fairly quick way of getting acquainted with a problem. &nbsp;It's also a good starting point for trying out other things. &nbsp;Lastly, it's better than nothing.<br /><br />With that in mind, I approached the puzzle as a search problem (a more general instance of the <a href="http://mishapenkov.blogspot.jp/2012/12/this-weeks-coding-practice-binary.html">binary search</a>). &nbsp;At each step, you represent the current state of the puzzle as 3 individual states. &nbsp;To get to the next steps, a disks is moved from one stack to another, without violating the rules of the puzzle. &nbsp;Once you get to a state in which all of the discs are on the second (or third) stack, then you've solved the puzzle. &nbsp;In which order should we look at the next steps? &nbsp;One simple way is DFS (<a href="http://mishapenkov.blogspot.jp/2013/02/coding-practice-depth-first-tree.html">depth-first search</a>).<br /><br />I quickly realized that a lot of the resulting steps weren't helpful in solving the puzzle: moving a single disc backwards and forwards between two rods achieves nothing. &nbsp;It also causes some branches of the DFS to be infinitely long, meaning the search will fail to terminate. &nbsp;One way to get around this problem is to search only those states that haven't been encountered yet. &nbsp;This requires keeping track of the states encountered thus far, which could be done with a <a href="http://mishapenkov.blogspot.jp/2012/12/last-weeks-coding-practice-hash-tables.html">hash map</a>.<br /><br />As it turns out, DFS isn't the best way to perform the search, since the solution it yields isn't necessarily the simplest. &nbsp;This can be addressed by switching to breadth-first search (BFS): the solution it yields will have the minimum possible number of steps (which, as it turns out, is equal to $2^{n-1}$).<br /><br />After writing my solution out on paper, I quickly coded it up in Python. &nbsp;Since I had a bit of spare time, I decided to try out my JavaScript chops and implement something I could show off graphically. &nbsp;While fiddling with JS took me way longer than coming up with the actual algorithm, I got there in the end, and came up with this:<br /><br /><iframe allowfullscreen="allowfullscreen" frameborder="0" src="http://jsfiddle.net/mpenkov/mRr8G/embedded/result" style="height: 300px; width: 100%;"></iframe><br /><br />The search problem can be taken further by implementing an <a href="http://en.wikipedia.org/wiki/A*_search_algorithm">A* search</a>&nbsp;that uses a heuristic to determine the best action to take at each step. &nbsp;If a suitable heuristic can be formulated, this kind of search can significantly reduce the running time and memory usage of the algorithm. &nbsp;It was tempting to keep digging, but I'll leave that to another day.<br /><br />Full source (including the Python code) is available as a <a href="https://gist.github.com/mpenkov/4729088">gist</a>.
