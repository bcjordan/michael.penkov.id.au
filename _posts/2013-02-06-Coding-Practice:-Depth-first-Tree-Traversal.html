---           
layout: post
title: Coding Practice - Depth-first Tree Traversal
date: 2013-02-06 07:46:56 UTC
updated: 2013-02-06 07:46:56 UTC
comments: false
categories: blog
---
 
A few weeks ago, I wrote about trees -- <a href="http://mishapenkov.blogspot.jp/2012/12/this-weeks-coding-practice-binary.html">binary search trees</a>, to be specific. &nbsp;Working with a tree, for example inserting or retrieving elements, often involve scanning through the elements of the tree, starting at the root. &nbsp;This is known as a <a href="http://en.wikipedia.org/wiki/Tree_traversal">traversal</a>.<br /><br />Unsurprisingly, there are many ways to perform a traversal. &nbsp;A major distinguishing factor is the order in which nodes are visited: if all children of a node are visited before any of the node's siblings, then the traversal is known as <i>depth-first</i>. &nbsp;If, on the other hand, the siblings are visited before the children, then the traversal is known as <i>breadth-first</i>. &nbsp;In this article, I'll focus on describing depth-first traversals.<br /><br />There are three main ways of traversing a binary tree depth-first: pre-order, in-order and post-order.  They are typically defined recursively, with each step of the recursion consisting of three sub-steps: do something to the current node (this is referred to as visiting), traverse the left subtree, traverse the right subtree.  By convention, the left subtree is traversed before the right subtree.  Pre-order, in-order and post-order traversals perform the visit sub-step before, in-between and after the two subtree traversals, respectively. &nbsp;Here's an <a href="http://en.wikipedia.org/wiki/Tree_traversal#Example">example</a> of performing each of the three traversal on a small tree.<br /><br />The big three traversal algorithms can be implemented recursively or iteratively.  Recursive implementations are easier to understand since they follow directly from definition, but can be less efficient than iterative implementations due to the function call overhead (for more details, see <a href="http://stackoverflow.com/questions/72209/recursion-or-iteration">http://stackoverflow.com/questions/72209/recursion-or-iteration</a>).<br /><br />Picking the traversal algorithm to use depends on the application.  For example, propagating changes from the leaf nodes to the root (e.g. calculating the sum of the tree) can only be accomplished with a post-order traversal, since the sum of each subtree needs to be known before the sum of the current node can be calculated.  In contrast, propagating changes from the root to the leaves would be best done with a pre-order traversal.<br /><br />The problems to solve this week were:<br /><ol><li>Implement a simple binary (non-search) tree node data structure in your favorite programming language and write the following methods: (1) print nodes pre-order, (2) print nodes in-order, (3) print nodes post-order.</li><li>Write a function that, given two nodes and a tree root, finds the two nodes' lowest common ancestor. That is, the function should find the ancestor that both nodes share that is furthest away from the root.</li></ol><div>I went with a C++ implementation this time to take advantage of the STL's sets and maps.  For finding the lowest common ancestor (LCA), I didn't use a parent pointer in the Node, and instead used an arbitrary traversal to calculate the parent of each node in the tree and store it in a map.  This costs $O(n)$ for both space and time.  Once that's done, finding all ancestors of one node and searching for the LCA both cost $O(log(n))$ given a data structure with a fast membership function (a set).  The approach is thus $O(n)$, but can be reduced to $O(log(n))$ if the results of the traversal are pre-calculated and stored somewhere. &nbsp;This pre-calculation would be practically identical to keeping parent pointers in each Node.</div><div><br /></div><div>The code is below:</div><div><br /></div><script src="https://gist.github.com/mpenkov/4535946.js"></script><div><br /></div>
