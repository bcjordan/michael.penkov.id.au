---           
layout: post
title: Coding Practice - Quicksort
date: 2013-04-22 10:15:34 UTC
updated: 2013-04-22 10:15:34 UTC
comments: false
categories: 
---
 
I've mentioned sorting algorithms <a href="http://mishapenkov.blogspot.jp/2013/03/coding-practice-binary-search.html">several</a> <a href="http://mishapenkov.blogspot.jp/2012/12/this-weeks-coding-practice-merge-sort.html">times</a> in the past, with a specific focus on <a href="http://mishapenkov.blogspot.jp/2012/12/this-weeks-coding-practice-merge-sort.html">Mergesort</a>. Today's article introduces Quicksort, another common sorting algorithm. The article starts with an intuitive, non-technical description. Next, the article presents the C code and a hand-wavy theoretical analysis of its computational complexity, backed by a pinch of practical results. The article concludes with a comparison with the Mergesort algorithm.<br /><br /><h3>Intuitive Description</h3><div><br /></div>The most intuitive description of the Quicksort algorithm is credited to its inventor, <a href="http://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a>:  <br /><blockquote class="tr_bq">"Just grab a thing and compare the other things with it."</blockquote>The trick is that Quicksort "grabs" and "compares" intelligently, avoiding unnecessary comparisons and allowing it to sort a collection in logarithmic time. Specifically, this is achieved by <i>partitioning</i>&nbsp;the collection around the thing we just grabbed (called the "pivot") into two smaller collections. Everything smaller than or equal to the pivot goes into the left sub-collection, and everything else goes into the right sub-collection. The two sub-collections can then be Quicksort-ed independently, recursively. The recursion terminates when the sub-collections contain less than two elements.<br /><br /><h3>Code and Analysis of Computational Complexity</h3><br />The code for Quicksort is fairly straightforward:<br /><br /><script src="https://gist.github.com/mpenkov/5301559.js?file=quicksort.c"></script> Most of the work is performed in the partition method, which can be implemented in-place.<br /><br />The computational complexity of Quicksort depends on the selection of the pivot element. In the best case, the selected pivot is the median of the collection and the partition step divides the collection into two smaller collections of identical size. Since the size of the sorted collection is halved at each step of the recursion, the best case complexity of Quicksort is $O(N \log N)$. In the worst case, the selected pivot is the minimum or maximum of the collection, and the partition step achieves very little. The worst case complexity is $O(N^2)$.<br /><br />There are several ways to select the pivot element, the simplest being selecting the first, last or middle element of the collection. Since selecting the first or last element can lead to worst-case performance if the array is already sorted, selecting the middle element is the better option of the three.<br /><br />The effect of pivot selection on the complexity of Quicksort can be observed empirically, by counting the number of comparisons for three different types of input: random, sorted and uniform; and for three different pivot selection methods: first, last and middle. Here are some results (sorting 100 input elements, showing the number of comparisons first, last, middle selection modes, respectively):<br /><div><ul><li>random (mean over 100 runs): 713.28, 715.17, 713.25&nbsp;</li><li>sorted: 1001, 1001, 543&nbsp;</li><li>same: 1001, 1001, 1001</li></ul><div>The above results support what is already well-known: merge sort performs worst when given sorted and uniform input. The former can be dealt with by selecting the middle element as the pivot (or even randomizing the pivot selection). The latter can be dealt with by checking for uniform input prior to sorting, which will take O(N).</div></div><div><br /></div><div><div>To obtain these results, I used GDB (to set breakpoints and count the number of hits), Python (to generate the input) and bash (to tie everything together). The entire code for reproducing these results is <a href="https://gist.github.com/mpenkov/5301559">here</a>.<br /><br /></div></div><h3>Comparison with Mergesort</h3><div><br /></div><a href="http://mishapenkov.blogspot.jp/2012/12/this-weeks-coding-practice-merge-sort.html">Mergesort</a> and Quicksort are both divide-and-conquer sorting algorithms. They work by first dividing the input data into parts and then recursively processing each part separately. However, there are significant differences between them.<br /><ol><li>First, Quicksort does all of its work in the divide (partition) step. The conquer step is trivial, since after recursion is complete, the array is completely sorted. In contrast, Mergesort does very little work in the divide step, and does most of its work after the recursion is complete.</li><li>Second, the algorithms have different computational complexity: Mergesort is consistent $O(N \log N)$, Quicksort is $O(N \log N)$, $O(N \log N)$ and $O(N^2)$ in the best, average and worst-case, respectively.</li><li>Third, the algorithms have different space complexity: unlike Mergesort, Quicksort's partition step can be implemented in-place without significant impact on complexity.</li><li>Fourth, unlike Mergesort, Quicksort is not a stable sorting algorithm, since the partition step reorders elements. Stable implementations of Quicksort do exist, but are not in-place.</li><li>Finally, Mergesort is easier to parallelize than Quicksort, since the divide step is simpler with the former.</li></ol><br /><h3>Conclusion</h3><div><br /></div><div>If you're one of the chosen few that managed to soldier on through the entire article, give yourself a pat on the back. Thanks for reading the entire thing. Please reward yourself with a refreshing chuckle at this sorting-related <a href="http://xkcd.com/1185/">xkcd.com comic</a>:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://imgs.xkcd.com/comics/ineffective_sorts.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="300" src="http://imgs.xkcd.com/comics/ineffective_sorts.png" width="320" /></a></div><br /></div>
